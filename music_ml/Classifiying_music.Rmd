---
title: "Classification of Audio segments by instrument: A Tutorial on using the R package `reticulate` to integrate R and Python."
author: "Emma Rand"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---
 

# Introduction
You are going to write your own tutorial by combining your own notes and investigations with the code given in the slides. The first part of the tutorial aims to develop our baseline understanding of the link between the R and Python sessions and running code chunks interactively in R Markdown; the second part covers the importing, modelling and visualisation of the processed audio data.

**The classification problem**

We are going to work with some data derived from 9 pieces of music.

The example and the original Python code to process the audio files and carry out the ML methods are by Michael Knight, University of Bristol.

Each of the pieces of music has been segmented into 5-second segments each of which has 5000 features. Upto 100 segments were taken from each audio file although there are fewer for pieces shorter than 500 seconds.

We will try to classify these segments. 

(would be good to process the audio into segments but requires pydub to be installled and environments and packages less straightforward. )


# Set up

```{r setup, include=FALSE}

knitr::opts_chunk$set(knitr::opts_chunk$set(echo = TRUE, 
                      warning = FALSE,
                      message = FALSE))
```

## R packages needed

```{r pkgs}
##########   R    ##########
library(reticulate)
library(ggplot2)

```

## Python libraries needed

```{python mods}
########## PYTHON ##########
import os
import pandas as pd

# for PCA
from sklearn.decomposition.pca import PCA

# for plotting
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

```

# Part 1: Building our understanding of the 'reticulation'

This section is not required for the analysis of the data but is here to give us some practice in dealing with the linked sessions. 

A Python equivalent for R's `getwd()` is from the `os` module.

```{python}
########## PYTHON ##########
os.getcwd()
```

It prints out! with escaped 'windows-way' round slashes

Just like...
```{r}
##########   R    ##########
getwd()

```

Using the `print()` command also works
```{python}
########## PYTHON ##########
print(os.getcwd())
```
However, notice the folder separators are the 'windows' way round and not escaped and not quoted

**Note** I found print needed in earlier versions - not sure what update fixed, possibly using the dev version of reticulate. you often need to use print statements explicitly in python

```{python}
########## PYTHON ##########
# what happens if we save the output of os.getcwd()
# and print later in an r chunk

# assign the a variable
direct = os.getcwd()
```

```{r}
##########   R    ##########

# access that variable
py$direct

```
the folder separators are the windows way round and escaped


```{r}
##########   R    ##########
# accessing the os method cwd 
# you do get command completion
py$os$getcwd()

```
the folder separators are the windows way round and escaped

What about running an r command from a python chunk?
```{python}
########## PYTHON ##########
r.getwd()

```


note:
the output of r's getwd has the slashes 'corrected'
This the case whether it is run from an r chunk or from a python chunk.

the output of python's os.getcwd has slashes the 'windows' way round
unless you're using it in an r chunk as `py$os$getcwd` or accessing the assigned output of os.getcwd run from python chunk where they are the windows way round and escaped.


# Part 2: Classification of audio data

overview of the data import needed

description of the _segments.xlsx and _SegmentInfo.xlsx 
can be downloaded directly


## Data import

```{python}
########## PYTHON ##########
# read data in
dirs_to_use = ["Violin", "Piano", "Violin_and_Piano"]

df_seg = None
df_info = None
for d in dirs_to_use:
    for f in os.listdir(d):
        if f.endswith("segments.xlsx"):
            if df_seg is None:
                df_seg = pd.read_excel(os.path.join(d, f))
            else:
                df_seg = df_seg.append(pd.read_excel(os.path.join(d, f)),
                                       ignore_index = True)
        elif f.endswith("SegmentInfo.xlsx"):
            if df_info is None:
                df_info = pd.read_excel(os.path.join(d, f))
                df_info["Instrument"] = pd.Series([d] * len(df_info),
                                                  index = df_info.index)
            else:
                df = pd.read_excel(os.path.join(d, f))
                df["Instrument"] = pd.Series([d]*len(df), index = df.index)
                df_info = df_info.append(df, ignore_index = True)


```

## Some descriptive information


## Analysis

### PCA in Python

```{python}
########## PYTHON ##########
# Apply PCA
mdl = PCA()
new_data = mdl.fit_transform(df_seg)
```

access info from the new_data object


### Visualising the ` r emo::ji("snake")` PCA

#### First using Python


Scree plot
```{python}
########## PYTHON ##########
plt.figure()
plt.plot(mdl.explained_variance_)
plt.show()

```


Biplot
```{python}
########## PYTHON ##########
# booleans for instrument
p = df_info["Instrument"] == "Piano"
v = df_info["Instrument"] == "Violin"
pv = df_info["Instrument"] == "Violin_and_Piano"
plt.figure()
plt.scatter(new_data[p, 0], new_data[p, 1], label = "Piano")
plt.scatter(new_data[v, 0], new_data[v, 1], label = "Violin")
plt.scatter(new_data[pv, 0], new_data[pv, 1], label = "Violin_and_Piano")
plt.legend()
plt.show()
```




#### Now using R

screeplot


Biplot

```{r}
##########   R    ##########
# pca 1 is in new_data[ ,1]
# pca 2 is in new_data[ ,2]

df <- data.frame(pca1 = py$new_data[ ,1], 
                 pca2 = py$new_data[ ,2], 
                 instrument = py$df_info$Instrument)

ggplot(data = df, aes(x = pca1, y = pca2, color = instrument)) +
  geom_point()
```





#### 3D plot in Python

Triplot of Python's PCA1 v PCA2 using Python
```{python}
########## PYTHON ##########
fig = plt.figure()
ax = Axes3D(fig)
ax.scatter(new_data[p, 0], new_data[p, 1], new_data[p, 2], label = "Piano")
ax.scatter(new_data[v, 0], new_data[v, 1], new_data[v, 2], label = "Violin")
ax.scatter(new_data[pv, 0], new_data[pv, 1], new_data[pv, 2], label = "Violin_and_Piano")
plt.legend()
plt.show()

```

 


